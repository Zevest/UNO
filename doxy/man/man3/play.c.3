.TH "UNO/play.c" 3 "Samedi 2 Mai 2020" "Version 1.3" "UNO" \" -*- nroff -*-
.ad l
.nh
.SH NAME
UNO/play.c
.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include 'include/pile\&.h'\fP
.br
\fC#include 'include/carte\&.h'\fP
.br
\fC#include 'include/joueur\&.h'\fP
.br
\fC#include 'include/csvloader\&.h'\fP
.br
\fC#include 'include/play\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBN\fP   13"
.br
.in -1c
.SS "Fonctions"

.in +1c
.ti -1c
.RI "void \fBplay_Next\fP ()"
.br
.RI "Passe au tour suivant\&. "
.ti -1c
.RI "int \fBplay_GetTour\fP ()"
.br
.RI "Renvoie la valeur des tours jouer\&. "
.ti -1c
.RI "void \fBplay_SetTour\fP (int n)"
.br
.RI "Modifie la valeur de tour\&. "
.ti -1c
.RI "void \fBplay_Inverse\fP ()"
.br
.RI "Change de sens\&. "
.ti -1c
.RI "int \fBplay_IsCardPlayable\fP (\fBcard_t\fP *carte_A, \fBcard_t\fP *carte_B)"
.br
.RI "Verifie si la carte peut être jouer\&. "
.ti -1c
.RI "int \fBplay_CanPlay\fP (\fBpile_t\fP *\fBmain\fP, \fBcard_t\fP *carte)"
.br
.RI "Verifie si un joueur peut jouer\&. "
.ti -1c
.RI "int \fBplay_CountPoint\fP (\fBplayer_t\fP *g, int joueur)"
.br
.RI "Compte le nombre de points d'un joueur\&. "
.ti -1c
.RI "int \fBplay_EndGame\fP (\fBplayer_t\fP *g, int joueur)"
.br
.RI "Additionne les points des perdants pour les atribuer au gagnant\&. "
.ti -1c
.RI "int \fBplay_Play\fP (\fBplayer_t\fP *joueurs, \fBpile_t\fP *paquets, \fBpile_t\fP *pioches, int numJoueur, int nbj, \fBcsv_t\fP *\fBcsv\fP)"
.br
.RI "Boucle principale du jeu\&. "
.in -1c
.SH "Documentation des macros"
.PP 
.SS "#define N   13"

.PP
Définition à la ligne 12 du fichier play\&.c\&.
.SH "Documentation des fonctions"
.PP 
.SS "int play_CanPlay (\fBpile_t\fP * main, \fBcard_t\fP * carte)"

.PP
Verifie si un joueur peut jouer\&. Vérifie si un joueur possède une carte jouable\&. 
.PP
\fBParamètres\fP
.RS 4
\fImain\fP pile des carte d'un joueur\&. 
.br
\fIcarte_b\fP dernière carte poser 
.RE
.PP
\fBRenvoie\fP
.RS 4
1 si le joueur peu jouer, 0 sinon\&. 
.RE
.PP

.PP
Définition à la ligne 55 du fichier play\&.c\&.
.SS "int play_CountPoint (\fBplayer_t\fP * g, int joueur)"

.PP
Compte le nombre de points d'un joueur\&. 
.PP
Définition à la ligne 68 du fichier play\&.c\&.
.SS "int play_EndGame (\fBplayer_t\fP * g, int joueur)"

.PP
Additionne les points des perdants pour les atribuer au gagnant\&. 
.PP
Définition à la ligne 95 du fichier play\&.c\&.
.SS "int play_GetTour ()"

.PP
Renvoie la valeur des tours jouer\&. Recupere la variable global du numero tour\&. 
.PP
\fBRenvoie\fP
.RS 4
numero du tour 
.RE
.PP

.PP
Définition à la ligne 24 du fichier play\&.c\&.
.SS "void play_Inverse ()"

.PP
Change de sens\&. Inverse la valeur de la varaiable global d'incémentation du tour\&. 
.PP
Définition à la ligne 35 du fichier play\&.c\&.
.SS "int play_IsCardPlayable (\fBcard_t\fP * carte_A, \fBcard_t\fP * carte_B)"

.PP
Verifie si la carte peut être jouer\&. 
.PP
Définition à la ligne 41 du fichier play\&.c\&.
.SS "void play_Next ()"

.PP
Passe au tour suivant\&. Increment la variable global comptant le numero du tour\&. 
.PP
Définition à la ligne 18 du fichier play\&.c\&.
.SS "int play_Play (\fBplayer_t\fP * joueurs, \fBpile_t\fP * paquets, \fBpile_t\fP * pioches, int numt, int nbj, \fBcsv_t\fP * csv)"

.PP
Boucle principale du jeu\&. Fonction principlale du jeu Fait jouer un joueur et effectue tous les tests\&. 
.PP
\fBParamètres\fP
.RS 4
\fIjoueurs\fP vecteur contenent les joueurs\&. 
.br
\fIpaquets\fP pile sur laquel les joueurs posent leur carte\&. 
.br
\fIpioche\fP pile : la pioche 
.br
\fInumt\fP indice du joueur 
.br
\fInbj\fP nombre de joueur 
.br
\fIcsv\fP ensemble des messages a afficher 
.RE
.PP

.PP
Définition à la ligne 118 du fichier play\&.c\&.
.SS "void play_SetTour (int n)"

.PP
Modifie la valeur de tour\&. Definie le numero du tour\&. 
.PP
\fBParamètres\fP
.RS 4
\fIn\fP nouvelle valeur du numero du tour\&. 
.RE
.PP

.PP
Définition à la ligne 30 du fichier play\&.c\&.
.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour UNO à partir du code source\&.
